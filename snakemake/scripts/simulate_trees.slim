// Parameters
// mu: mutation rate
// s_d: selection coefficient for deleterious mutations
// s_b: selection coefficient for beneficial mutations
// b: shape parameter for gamma distribution
// p_b: proportion of beneficial mutations
// h: dominance coefficient for deleterious mutations (if applicable)
// r: recombination rate
// N: population size
// g: generation to stop simulation
// length: sequence length
// demography: demographic events ('constant', 'expansion', 'bottleneck', 'reduction', 'substructure', 'dominance')

initialize()
{
    //setSeed(23); // For reproducibility
    initializeSLiMModelType("WF"); // Wright-Fisher model
    initializeTreeSeq(); // tree sequence recording
    initializeMutationRate(mu); // mutation rate

    // gamma distribution for deleterious mutations
    // SLiM defines fitness effects as 1 + hs and 1 + s for heterozygous and homozygous genotypes respectively
    // In fastDFE, we define them as 1 + 2hs and 1 + 2s, so we need to adjust s by a factor of 2 here
    initializeMutationType("m1", 0.5, "g", - 2 * s_d, b);

    // exponential distribution for beneficial mutations
    initializeMutationType("m2", 0.5, "e", 2 * s_b);

    // adjusting the proportion of deleterious and beneficial mutations
    initializeGenomicElementType("g1", c(m1, m2), c(1 - p_b, p_b));

    initializeGenomicElement(g1, 1, length); // sequence length
    initializeRecombinationRate(r); // recombination rate
}

1 early() {
    sim.addSubpop("p1", N);

    if (demography == "substructure") {
        // split population into two subpopulations with migration
        sim.addSubpopSplit("p2", asInteger(N / 2), p1);
        p1.setMigrationRates(p2, k);
        p2.setMigrationRates(p1, k);
    }
}

// custom dominance coefficient function for deleterious mutations
mutationEffect(m1) {
    if (homozygous) {
        return 1.0 + mut.selectionCoeff;
    } else {
        if (demography == "dominance_function") {
            // remove scaling of 2 to base mapping on `real` s values
            dom = max(0.4 * exp(-k * abs(mut.selectionCoeff) / 2), 0.1);
        } else {
            dom = h;
        }
        return 1.0 + dom * mut.selectionCoeff;
    }
}

// custom dominance coefficient function for beneficial mutations
mutationEffect(m2) {
    if (homozygous) {
        return 1.0 + mut.selectionCoeff;
    } else {
        if (demography == "dominance_function") {
            // remove scaling of 2 to base mapping on `real` s values
            dom = max(0.4 * exp(-k * abs(mut.selectionCoeff) / 2), 0.1);
        } else {
            dom = h;
        }
        return 1.0 + dom * mut.selectionCoeff;
    }
}

early() {
    if (demography == "expansion") {
        if (community.tick == g - 500) {
            // population expands to k times original size 500 generations before stopping
            p1.setSubpopulationSize(asInteger(k * N));
        }
    }

    if (demography == "reduction") {
        if (community.tick == g - 500) {
            // population reduces to 1 / k of original size 500 generations before stopping
            p1.setSubpopulationSize(asInteger(N / k));
        }
    }

    if (demography == "bottleneck") {
        if (community.tick == g - 600) {
            // bottleneck to 1 / k of original size 600 generations before stopping
            p1.setSubpopulationSize(asInteger(N / k));
        }

        if (community.tick == g - 500) {
            // recover to original size 500 generations before stopping
            p1.setSubpopulationSize(N);
        }
    }
}

1:100000000
late()
{
    // print status
    cat("\r" + paste("Progress:", (community.tick / g) * 100, "% (Generation ", community.tick, " of ", g, ")"));

    // noinspection all
    if (community.tick == g) {

        // compute FST once at the end (only makes sense for substructure)
        if (demography == "substructure") {
            fst = calcFST(p1.haplosomes, p2.haplosomes);
            cat("\nFinal FST between p1 and p2: " + fst + "\n");
            writeFile(out_stats, "fst\n" + fst + "\n");
        }

        sim.treeSeqOutput(out_trees);
        sim.simulationFinished();
    }
}
